from tkinter import *
from tkinter import ttk
from tkinter import filedialog
import cv2
import numpy as np
from PIL import Image,ImageTk

finestra=Tk()
#titolo
finestra.title("Interfaccia grafica")
#dove la faccio spawnare 
finestra.geometry('600x400+30+50')

frame1=Frame(finestra,background="grey",height=100,width=300)
frame1.pack(fill=X,side='bottom')


#Possibilita di scegliere il tipo di selzione sull'immagine
#se volessi associare un valore ai vari radiobutton avrei attributo value
#unica variabile perche tutti i radiobutton fanno riferimento alla stessa
scelta=StringVar()

scelta.set("q")#imposto quadrato come scelto inizialmente 
quadrato=Radiobutton(frame1,text="Quadrato",variable=scelta,value="q")
cerchio=Radiobutton(frame1,text="Cerchio",variable=scelta,value="c")
disegno_libero=Radiobutton(frame1,text="Disegno Libero",variable=scelta,value="d")

#bottone generazione heatmap,ora uso una 
#lambda expression, poi metterei bottone generazione
prova=Button(frame1,text='Genera Heatmap',command=lambda:print(scelta.get()))

'''def paint( event ):
   python_green = "#476042"
   x1, y1 = ( event.x - 1 ), ( event.y - 1 )
   x2, y2 = ( event.x + 1 ), ( event.y + 1 )
   w.create_oval( x1, y1, x2, y2, fill = python_green )'''
prova.pack(side='right',padx=2)
disegno_libero.pack(side='right')
cerchio.pack(side='right')
quadrato.pack(side='right')

mia_canvas=Canvas(finestra)
mia_canvas.pack(fill=BOTH,expand=True)
immagine=None#cosi quando è Null non faccio disegnare sull'area di lavoro, ma faccio disegnare solo quando sara libera
immagine_originale=None

def carica_immagine():
    global immagine,immagine_originale#oppure il garbage collector lo distrugge e non me lo fa vedere quando metodo finisce
    percorso_foto=filedialog.askopenfilename()
    image=cv2.imread(percorso_foto)
    #devo portarla in un formato leggibile da tkinter
    image=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
    immagine_originale=Image.fromarray(image)
    immagine=ImageTk.PhotoImage(image=Image.fromarray(image))
    mia_canvas.create_image(0,0,image = immagine, anchor =NW)
    #adatto dimensione della finestra a quella della foto cosi si vede bene
    finestra.geometry(f"{immagine.width()}x{immagine.height()}")
    #commento queste righe se voglio dare possibilita di allargare la finestra dopo l'inserimento della foto
    #finestra.maxsize(immagine.width(), immagine.height())
   

bottone=Button(frame1,text='Carica Immagine',command=carica_immagine)
bottone.pack(side='left')

#lista dei disegni con annesse coordinate, potrebbero servirmi per eventuali maschere da creare nella generazione della heatmap
coord_disegni=[]



#variabili per gestire disegno
mouse_premuto = False
inizio_x=None
inizio_y=None
ultima_x=None
ultima_y=None
dati=[]
def inizio_selezione(event):
    global mouse_premuto,inizio_x,inizio_y,ultima_x,ultima_y
    if immagine is not None:
        mouse_premuto=True
        inizio_x=event.x
        inizio_y=event.y
        ultima_x=event.x
        ultima_y=event.y
        if(scelta.get()=="d"):
            dati.append(event.x)
            dati.append(event.y)

def selezione_in_corso(event):
    if immagine is not None:
        global ultima_x,ultima_y
        if mouse_premuto:
            if scelta.get()=="c":
                mia_canvas.delete("cerchio_temporaneo")
                mia_canvas.create_oval(inizio_x, inizio_y, event.x, event.y, outline="black", tags="cerchio_temporaneo")
            if scelta.get()=="q":
                mia_canvas.delete("quadrato_temporaneo")
                mia_canvas.create_rectangle(inizio_x, inizio_y, event.x, event.y, outline="black", tags="quadrato_temporaneo")           

disegni_fatti_quando_cera_zoom=[]
zoomato=False

def fine_selezione(event):
    if immagine is not None:
        global mouse_premuto
        mouse_premuto=False
        if scelta.get()=="c":
            #ho quattro coordinate perche passo per il rettangolo che inscrive questa circonferenza
            mia_canvas.create_oval(inizio_x,inizio_y,event.x,event.y,outline="black",tags="cerchio")
            if zoomato:
                disegni_fatti_quando_cera_zoom.append(("cerchio",inizio_x,inizio_y,event.x,event.y))
            else:
                coord_disegni.append(("cerchio",inizio_x,inizio_y,event.x,event.y))
        if scelta.get()=="q":
            mia_canvas.create_rectangle(inizio_x,inizio_y,event.x,event.y,outline="black",tags="cerchio")
            if zoomato:
                disegni_fatti_quando_cera_zoom.append(("quadrato",inizio_x,inizio_y,event.x,event.y))
            else:
                coord_disegni.append(("quadrato",inizio_x,inizio_y,event.x,event.y))

            
    
            
    
#con bind sto associando la chiamata di una funzione ad un evento sulla mia canvas, in questo caso gli eventi sono 3:
#click del tasto sx, cosi utente inzia a selezionare area su cui disegnare,
#spostamento cursore cosi vede la figura crearsi mentre disegna
#click dx cosi finisce di disegnare 
mia_canvas.bind('<Button-1>',inizio_selezione)
mia_canvas.bind('<Motion>', selezione_in_corso)
mia_canvas.bind('<ButtonRelease-1>',fine_selezione)


def reset():
    mia_canvas.delete("cerchio")
    mia_canvas.delete("cerchio_temporaneo")
    mia_canvas.delete("quadrato")
    mia_canvas.delete("quadrato_temporaneo")
    mia_canvas.delete("mano_libera")
    coord_disegni.clear()
    

def elimina_ultimo():
    if len(coord_disegni)==0:
        return
    ultimo_disegno=coord_disegni[-1]
    trovato=False
    tutti_disegni=mia_canvas.find_all()
    for disegno in tutti_disegni:
        coord_disegno=mia_canvas.coords(disegno)
        cord_da_elimin1= ultimo_disegno[1]
        cord_da_elimin2=ultimo_disegno[2]
        cord_da_elimin3=ultimo_disegno[3]
        cord_da_elimin4=ultimo_disegno[4]
        if coord_disegno==[cord_da_elimin1,cord_da_elimin2,cord_da_elimin3,cord_da_elimin4] or coord_disegno==[cord_da_elimin3,cord_da_elimin4,cord_da_elimin1,cord_da_elimin2]:
            mia_canvas.delete(disegno)
            trovato=True
    if trovato:
        coord_disegni.remove(ultimo_disegno)
            

def redraw_drawings():
    #sus questa prima istruzione o no?
    mia_canvas.delete("all")
    mia_canvas.create_image(0, 0, image=immagine, anchor=NW)
    for disegno in coord_disegni:
        if disegno[0] == "cerchio":
            mia_canvas.create_polygon(disegno[1], disegno[2], disegno[3], disegno[4], outline="black", tags="cerchio")
        elif disegno[0] == "quadrato":
            mia_canvas.create_rectangle(disegno[1], disegno[2], disegno[3], disegno[4], outline="black", tags="quadrato")
        elif disegno[0] == "mano_libera":
            #da riguardare perchè cosi si sminchia tutto, ma se devo fare riconoscimento figura tanto non dovrebbe esserci sto problema
            mia_canvas.create_line(disegno[1], disegno[2], disegno[3], disegno[4], fill="black", tags="mano_libera")


def controlla_se_fatti_disegni():
    if len(disegni_fatti_quando_cera_zoom)==0:
        return
    else:
         # Calcoliamo il fattore di scala dell'immagine rispetto all'originale
        fattore_scala_x = immagine_originale.width / mia_canvas.winfo_width()
        fattore_scala_y = immagine_originale.height / mia_canvas.winfo_height()
        print(str(fattore_scala_x)+","+str(fattore_scala_y))
        
        for disegno in disegni_fatti_quando_cera_zoom:
            tipologia=disegno[0]
            x1 = (disegno[1] - mia_canvas.winfo_width() / 2) * 3.0
            y1 = (disegno[2] - mia_canvas.winfo_height() / 2) * 3.0
            x2 = (disegno[3] - mia_canvas.winfo_width() / 2) * 3.0
            y2 = (disegno[4] - mia_canvas.winfo_height() / 2) * 3.0
            if tipologia=="cerchio":
                coord_disegni.append(disegno)
                mia_canvas.create_oval(x1,y1,x2,y2, fill="black", tags="mano_libera")
                print("creato")
            else:
                coord_disegni.append(disegno)
                mia_canvas.create_rectangle(x1,y1,x2,y2, fill="black", tags="mano_libera")
                print("creato")
            disegni_fatti_quando_cera_zoom.remove(disegno)

def zoom_immagine(factor, ingrandire, x=None, y=None):
    global immagine, coord_disegni
    nuova_dimensione = (int(immagine_originale.width * factor), int(immagine_originale.height * factor))
    immagine = ImageTk.PhotoImage(image=immagine_originale.resize(nuova_dimensione))
    if ingrandire:
        mia_canvas.create_image(-x * factor + mia_canvas.winfo_width() / 2, -y * factor + mia_canvas.winfo_height() / 2, image=immagine, anchor=NW)
        #va fatto controllo se utente ha disegnato mentre c'era zoom adattando disegni
    else:
        mia_canvas.create_image(0, 0, image=immagine, anchor=NW)
        controlla_se_fatti_disegni()
        redraw_drawings()

def do_zoom(event):
    global zoomato
    factor = 3.0 if not zoomato else 1.0
    x = mia_canvas.canvasx(event.x)
    y = mia_canvas.canvasy(event.y)
    if not zoomato:
        zoom_immagine(factor, True, x, y)
        zoomato = True
        
    else:
        zoom_immagine(factor, False,0,0)
        zoomato = False






mia_canvas.bind('<ButtonPress-3>', do_zoom)

bottone=Button(frame1,text='Reset',command=reset)
bottone.pack(side='left')

bottone=Button(frame1,text='Undo',command=elimina_ultimo)
bottone.pack(side='left')

#altrimenti non si apre
finestra.mainloop()